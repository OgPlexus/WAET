
# coding: utf-8

# In[2]:


get_ipython().run_cell_magic('time', '', '\nimport networkx as nx\nimport random as rnd\nimport numpy as np\nfrom random import choice\nfrom scipy.stats import nbinom\nfrom networkx.generators.community import stochastic_block_model\nimport itertools as it\nfrom scipy.stats import norm\nfrom scipy.stats import beta\nfrom numpy import prod\nimport math\nimport os\nimport pickle\nimport sys\n\n# JOB_ID = sys.argv[1]\n# TASK_ID = sys.argv[2]\n\n\n# these two functions save and load resp. .pkl files:\n\ndef save_obj(obj, name):\n    with open(\'Python/obj/\'+ name + \'.pkl\', \'wb\') as f:\n        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)\n\ndef load_obj(name):\n    with open(\'Python/obj/\' + name + \'.pkl\', \'rb\') as f:\n        return pickle.load(f)\n    \ndef energy(graph):\n    to_sum = []\n    for edge in graph.edges():   \n        a = -1 + 2*graph.nodes[edge[0]][\'health\']  # maps 0,1 to -1,1\n        b = -1 + 2*graph.nodes[edge[1]][\'health\']\n        to_sum.append(-a*b)\n    return sum(to_sum)\n\ndef sick(p_sick):           # this will return 1 if dice roll is less than the input p_sick, returns 0 otherwise\n    if rnd.random()<p_sick:\n        return 1\n    else:\n        return 0\n\ndef BETA(mean,var):   # returns the a and b params for the beta dist. given mean and variance\n    a = mean*(mean*(1-mean)-var)/var\n    b = (1-mean)*(mean*(1-mean)-var)/var\n    return a,b\n\ndef candidate(graph,node):\n    candidates = []\n    for nde in graph.neighbors(node):\n        candidates.extend([(nde,x) for x in graph.neighbors(nde) if graph.nodes[x][\'block\']==graph.nodes[nde][\'block\'] and x not in [node]+list(graph.neighbors(node))])\n        \n    return candidates\n    \ndef clearance(alpha0,num,p0,p1,p_clear): # alpha0 gives the % of type 0 in num (1-alpha0 is the % of type 1), p0 gives the % of alpha0*num that has the clearane allele, p1 gives the corresponding % of (1-alpha0)*num; all are randomly put into an array of len = num\n    if num>1:\n        n_0 = int(alpha0*num)        # number of type 0\n        n_1 = num - int(alpha0*num)  # number of type 1\n\n        n_00 = n_0 - int(p0*n_0)     # num of type 0 w/o clearance allele\n        n_01 = int(p0*n_0)           # num of type 0 w/ clearance allele\n        n_10 = n_1 - int(p1*n_1)     # num of type 1 w/o clearance allele\n        n_11 = int(p1*n_1)           # num of type 1 w/ clearance allele\n\n        """ the first 0 or 1 indicates the group type """\n        """ the second 0 or 1 indicates whether the clearance allele is present """\n        """ if value in array is nonzero, clearance allele is present """\n\n        a_00 = list(zip(np.zeros(n_00),[0]*n_00)) \n        a_01 = list(zip([p_clear]*n_01,[0]*n_01))  \n        a_10 = list(zip(np.zeros(n_10),[1]*n_10)) \n        a_11 = list(zip([p_clear]*n_11,[1]*n_11))\n\n        c = a_00+a_01+a_10+a_11\n        rnd.shuffle(c)\n        return c\n    else:   # the case when num = 1\n        if rnd.random()<alpha0:      # randomly decides if type 0\n            if rnd.random()<p0:      # if agent has clearance capability\n                return (p_clear,0) # type 0 w/ clearance capability\n            else:\n                return (0,0)       # type 0 w/o clearance capability\n        elif rnd.random()<p1:    # if the agent is type 1 then if has clearance capability\n            return (p_clear,1) # type 1 w/ clearance capability\n        else:                    \n            return (0,1)       # type 1 w/o clearance capability\n\ndef HCV_ABM_2(graph,positions,p_decay,p_birth,p_death,t_steps,no_blocks=2): # needles is a list of lists [a,b] where a = num of clean needles and b = num of infected needles\n    \n    birth = 0\n    death = 0\n    \n    g = graph\n    nodes = g.nodes\n    edges = g.edges\n    \n    \n    Energy = []\n    \n    N_sick_0 = [len([x for x in g if nodes[x][\'health\']==1 and nodes[x][\'immunity_type\']==0])]\n    N_sick_1= [len([x for x in g if nodes[x][\'health\']==1 and nodes[x][\'immunity_type\']==1])]\n    N_healthy_0 = [len([x for x in g if nodes[x][\'health\']==0 and nodes[x][\'immunity_type\']==0])]\n    N_healthy_1 = [len([x for x in g if nodes[x][\'health\']==0 and nodes[x][\'immunity_type\']==1])]\n    \n   \n    #------------------------------------ this section for printing the network ------------------------------------#\n    \n#     graph_size = [15,9]\n#     colors = []\n    \n#     for node in g.nodes():\n#         if g.nodes[node][\'health\']==1:\n#             colors.append(\'red\')\n#         else:\n#             colors.append(\'blue\')\n        \n#     needl_labls = {} # to display the needle quantities\n#     for node in g.nodes():\n#         needl_labls.update({node:g.nodes[node][\'needles\']})\n    \n#     node_names = {} # to display the node labels\n#     for node in g.nodes():\n#         node_names.update({node:node})\n        \n#     rand_pos = nx.spring_layout(g,pos=positions,fixed=positions.keys())\n# #     rand_pos = positions  # uses the positions generated outside the function    \n# #     rand_pos = nx.kamada_kawai_layout(g)  # aesthetic layout\n# #     rand_pos = nx.spring_layout(g)   # another layout\n# #     rand_pos = nx.spectral_layout(g,dim=2)   # yet another layout\n    \n#     labls_pos = {}  # needle label positions\n#     for pt in rand_pos:\n#         labls_pos.update({pt:rand_pos[pt]+np.array([0.05,0.05])}) # this will shift the labels a little to the right and up\n        \n#     nde_labl_pos = {}  # node label positions\n#     for pt in rand_pos:\n#         nde_labl_pos.update({pt:rand_pos[pt]-np.array([0.05,0.05])}) # this will shift the labels a little to the left and down\n    \n#     fig,ax = plt.subplots(figsize=graph_size)\n#     plt.axis(\'off\')\n#     nx.draw_networkx(g,pos=rand_pos,node_color=colors,edgelist=[],with_labels=False,node_size=[300*g.nodes[nde][\'p_use\'] for nde in g.nodes()])\n#     nx.draw_networkx_edges(g,pos=rand_pos,width=[5*g.edges[x,y][\'wght\'] for (x,y) in g.edges()])\n#     nx.draw_networkx_labels(g,pos=labls_pos,labels=needl_labls)  # needle labels\n#     nx.draw_networkx_labels(g,pos=nde_labl_pos,labels=node_names,font_weight=\'bold\',font_size=15) # node labels\n#     plt.show()\n    \n    #---------------------------------------------------------------------------------------------------------------#\n    \n    clean_ndls = [sum([nodes[nds][\'needles\'][0] for nds in nodes])]  # initial num of clean needles\n    infct_ndls = [sum([nodes[nds][\'needles\'][1] for nds in nodes])]  # initial num of infected needles\n    \n    Energy.append(energy(g))\n    \n    degrees = []    # will house the number of edges in the graph over time\n    \n    edges_no = []\n\n    for t in range(t_steps): # a time step represents the time scale associated with needle-exchanges of a given % of the population of users (controlled by the various probabilities)\n        \n        if rnd.random()<p_birth:   # if a new node is introduced\n            \n            """ we define some parameters for new nodes """\n            a_break,b_break = BETA(0.01111,0.0001)  \n            a_link,b_link = BETA(0.9,0.01)\n            \n            info = {\'size\':50,\'immunity\':(260,7000),\'lend\':(25,2),\'accept\':(25,2),\'use\':(5,5),\'break\':(a_break,b_break),\'link\':(a_link,b_link),\'drug_a\':(7,3),\'drug_b\':(5,5),\'drug_c\':(3,7)}\n            \n            node_num = 1+max(g)\n            Immunity = clearance(0,1,p0,p1,0.00444) if rnd.random()<0.5 else clearance(1,1,p0,p1,0.00444) # randomly selects type 0 or 1\n            immunity = Immunity[0]\n            immunity_type = Immunity[1]\n            block_num = immunity_type\n            P_lend = beta(info[\'lend\'][0],info[\'lend\'][1]).rvs()\n            P_accept = beta(info[\'accept\'][0],info[\'accept\'][1]).rvs()\n            P_use = beta(info[\'use\'][0],info[\'use\'][1]).rvs()\n            P_break = beta(info[\'break\'][0],info[\'break\'][1]).rvs()\n            P_link = beta(info[\'link\'][0],info[\'link\'][1]).rvs()\n            Drug_a = beta(info[\'drug_a\'][0],info[\'drug_a\'][1]).rvs()\n            Drug_b = beta(info[\'drug_b\'][0],info[\'drug_b\'][1]).rvs()\n            Drug_c = beta(info[\'drug_c\'][0],info[\'drug_c\'][1]).rvs()\n            Age = int(norm(33,5).rvs())    # normal distribution of ages centered on 33 spread of 5\n            Target = nbinom(3,0.6).rvs()   # target number of neighbors\n            block_ndes = [nde for nde in g if nodes[nde][\'block\']==block_num]\n            \n            g.add_node(node_num,block=block_num,needles=[rnd.randint(1,3),0],health=0,immunity=immunity,immunity_type=immunity_type,p_lend=P_lend,p_accept=P_accept,p_use=P_use,p_break=P_break,p_link=P_link,drug_a=Drug_a,drug_b=Drug_b,drug_c=Drug_c,age=Age,target=Target)\n            birth += 1\n\n            \n            A = sum([g.degree(nde) for nde in block_ndes]) \n            if A>0:    # if the normalization is non-zero\n                \n                pop_node = np.random.choice(block_ndes,p=[g.degree(nde)/A for nde in block_ndes]) # selected node in block based on degree popularity\n\n                a = nodes[pop_node][\'p_use\']\n                b = nodes[node_num][\'p_use\']\n                x = nodes[pop_node][\'p_lend\']\n                y = nodes[node_num][\'p_lend\']\n                dd = sum([nodes[node_num][drug]*nodes[pop_node][drug] for drug in [\'drug_a\',\'drug_b\',\'drug_c\']])\n\n                g.add_edge(node_num,pop_node,color=\'k\',wght=a*b*(x+y)*dd)      # create a new edge\n\n        NODES = list(g.nodes())\n        rnd.shuffle(NODES)\n        \n        for node in NODES: \n            \n            Node = g.nodes[node]\n            \n            if Node[\'health\']==1 and rnd.random()<Node[\'immunity\']: \n\n                Node[\'health\']=0 # the infected user recovers with a probability per time step\n\n#                 print(node,\'recovers\')\n                    \n            if rnd.random()<Node[\'p_use\']: # if user decides to inject\n            \n                if rnd.random()<(Node[\'p_lend\']+Node[\'p_accept\'])/2: # if user decides to share needles\n                    \n                    nhbrs = list(g.neighbors(node))\n                    rnd.shuffle(nhbrs)\n                    \n                    for nhbr in nhbrs: # iterates thru neighbors of the node\n\n                        if rnd.random()<edges[node,nhbr][\'wght\']/2: # we divide by 2 since each edge has 2 chances for an event to occur\n\n                            g.add_edge(node,nhbr,color=\'r\')\n\n\n                            if Node[\'health\']==g.nodes[nhbr][\'health\']: # like meets like case\n\n                                if Node[\'health\']==1: # this is the sick meets sick case\n\n                                    x = nhbr if Node[\'p_lend\']<g.nodes[nhbr][\'p_lend\'] else node # host with the higher p_lend will lend\n      \n                                    ax = nodes[x][\'needles\'][0]  # num of clean needles for user x\n                                    bx = nodes[x][\'needles\'][1]  # num of infected needles for user x\n\n                                    # modifying the % of clean needles in an infected user\'s collection\n                                    if rnd.random()<ax/(ax+bx):  # chances that the needle is clean\n\n                                        nodes[x][\'needles\'][0]-=1  # a clean needle is lost \n                                        nodes[x][\'needles\'][1]+=1  # an infected needle is gained\n#                                         print(\'needle infected at\',x)\n\n                                else:  # this is the healthy meets healthy case\n\n                                    x = nhbr if Node[\'p_lend\']<g.nodes[nhbr][\'p_lend\'] else node # host with the higher p_lend, call it x, gives the needle, say\n                       \n                                    ax = nodes[x][\'needles\'][0]  # num of clean needles for user x\n                                    bx = nodes[x][\'needles\'][1]  # num of infected needles for user x\n\n                                    # healthy user injects first then shares (there\'s a chance the user has an infected needle)\n                                    if rnd.random()<bx/(ax+bx):  # chances that the needle is infected\n\n                                        nodes[nhbr][\'health\']=1    # both users\n                                        Node[\'health\']=1    # become infected\n\n\n                            else: # healthy meets sick case\n\n                                healthy_user = [user for user in [node,nhbr] if nodes[user][\'health\']==0][0]   # picks out the healthy one in the pair\n                                sick_user = [user for user in [node,nhbr] if nodes[user][\'health\']==1][0]  # picks out the sick one in the pair\n\n                                if  nodes[sick_user][\'p_lend\']<nodes[healthy_user][\'p_lend\']: # host with the higher p_lend gives the needle, say.\n\n                                    a = nodes[healthy_user][\'needles\'][0]  # num of clean needles for user x\n                                    b = nodes[healthy_user][\'needles\'][1]  # num of infected needles for user x\n\n                                    if rnd.random()<a/(a+b): # if a clean needle was selected by the uninfected user\n\n                                        nodes[healthy_user][\'needles\'][0]-=1  # uninfected user gives to infected (with needle return)\n                                        nodes[healthy_user][\'needles\'][1]+=1  # and an infection of a clean needle occurs\n                                    else:\n\n                                        nodes[healthy_user][\'health\']=1  # if selection of an infected needle occurs, the healthy user is assumed to use it before sharing, and therefore become infected\n                                else:  # infected user gives needle to uninfected user (again, the lender is assumed to inject first then lend, in which case the healthy user becomes infected) \n\n                                    a = nodes[sick_user][\'needles\'][0]  # num of clean needles for user x\n                                    b = nodes[sick_user][\'needles\'][1]  # num of infected needles for user x\n\n                                    nodes[healthy_user][\'health\']=1 # healthy user becomes infected regardless of the type of needle selected\n\n                                    if rnd.random()<a/(a+b): # if a clean needle is selected by the infected user:\n\n                                        nodes[sick_user][\'needles\'][0]-=1  # uninfected needle becomes infected\n                                        nodes[sick_user][\'needles\'][1]+=1  # from an injection by the infected user\n\n    #---------- this is where I\'m at ---------------#\n    \n            if rnd.random()<p_decay and Node[\'needles\'][1]>0: \n               \n                Node[\'needles\'][0]+=1   # with prob. p_decay (and if the user has any infected needles)\n                Node[\'needles\'][1]-=1   # an infected needle will "decay" to a clean one\n\n\n            # the below section breaks/creates an edge based on whether node is below their target\n\n            avlble_nodes = [nde for nde in nodes if g.degree(nde)<nodes[nde][\'target\']] # list of available nodes\n            \n            cands = candidate(g,node)\n            lenc = len(cands) \n            \n            if lenc>0 and rnd.random()<g.nodes[node][\'p_break\']: # if node decides to break an edge\n                s = sum([1/edges[node,nhbr][\'wght\'] for nhbr in [x[0] for x in cands]])\n                wghts = [1/(s*edges[node,nhbr][\'wght\']) for nhbr in [x[0] for x in cands]] # this maps x -> 1/x (and normalizes) where x is one of n edge weights; this way probabilities are inverted\n                break_index = np.random.choice(range(lenc),p=wghts) \n                break_node,bond_node=cands[break_index]\n                \n                g.remove_edge(node,break_node)  # removes the edge\n                \n                b_node = g.nodes[bond_node]\n                \n                a = Node[\'p_use\']\n                b = b_node[\'p_use\']\n                x = Node[\'p_lend\']\n                y = b_node[\'p_lend\']\n                dd = sum([Node[drug]*b_node[drug] for drug in [\'drug_a\',\'drug_b\',\'drug_c\']])\n\n                g.add_edge(node,bond_node,color=\'k\',wght=a*b*(x+y)*dd) \n\n\n#             if len(avlble_nodes)>1 and rnd.random()<Node[\'p_link\'] and node in avlble_nodes:  # if there are at least two available nodes\n\n#                 if len(list(g.neighbors(node)))>0:\n        \n#                     next_nhbrs = []    # will house nodes one agent removed from node (i.e. two hops away)\n\n#                     for nde in g.neighbors(node):\n#                         next_nhbrs.extend(list(g.neighbors(nde)))\n\n#                     next_nhbrs = list(set(next_nhbrs))\n#                     next_nhbrs.remove(node)\n\n#                     for nde in next_nhbrs:\n#                         if nde in g.neighbors(node):\n#                             next_nhbrs.remove(nde)      # selects only those nodes which are two hops from node\n\n#                     avlble_nhbrs = [x for x in next_nhbrs if x in avlble_nodes]\n\n#                     if len(avlble_nhbrs)>0:\n\n#                         avlble_norm = sum([g.nodes[nde][\'p_link\'] for nde in avlble_nhbrs])\n\n#                         new_node = np.random.choice(avlble_nhbrs,p=[g.nodes[nde][\'p_link\']/avlble_norm for nde in avlble_nhbrs])   # choose a random available node\n\n#                         a = g.nodes[node][\'p_use\']\n#                         b = g.nodes[new_node][\'p_use\']\n#                         x = g.nodes[node][\'p_lend\']\n#                         y = g.nodes[new_node][\'p_lend\']\n#                         dd = sum([g.nodes[node][drug]*g.nodes[new_node][drug] for drug in [\'drug_a\',\'drug_b\',\'drug_c\']])\n\n#                         g.add_edge(node,new_node,color=\'k\',wght=a*b*(x+y)*dd)      # create a new edge\n# #                         print(\'new edge at\',(node,new_node))\n#                 else:\n                    \n#                     block_ndes = [nde for nde in g if g.nodes[nde][\'block\']==g.nodes[node][\'block\']]\n                    \n#                     if sum([g.degree(nde) for nde in block_ndes])>0:    # if the normalization is non-zero\n                        \n#                         pop_node = np.random.choice(block_ndes,p=[g.degree(nde)/sum([g.degree(nde) for nde in block_ndes]) for nde in block_ndes]) # selected node in block based on degree popularity\n\n#                         a1 = g.nodes[pop_node][\'age\']\n#                         a2 = g.nodes[node][\'age\']\n#                         b1 = g.nodes[pop_node][\'immunity_type\']\n#                         b2 = g.nodes[node][\'immunity_type\']\n#     #                     print(pop_node, node)\n\n#                         if rnd.random()<1/(1+abs(a1-a2)+abs(b1-b2)):   # if a link is formed \n#                             a = g.nodes[pop_node][\'p_use\']\n#                             b = g.nodes[node][\'p_use\']\n#                             x = g.nodes[pop_node][\'p_lend\']\n#                             y = g.nodes[node][\'p_lend\']\n#                             dd = sum([g.nodes[node][drug]*g.nodes[pop_node][drug] for drug in [\'drug_a\',\'drug_b\',\'drug_c\']])\n\n#                             g.add_edge(node,pop_node,color=\'k\',wght=a*b*(x+y)*dd)      # create a new edge\n# #                             print(\'new edge at\',(node,pop_node))\n\n            if Node[\'health\']==1: # if user is infected\n                    \n                if rnd.random()<p_death and Node[\'immunity\']==0:\n                        \n                    g.remove_node(node)     # agent leaves network\n                    death += 1\n\n                       \n                elif rnd.random()<Node[\'p_use\']:\n                        \n                    a = Node[\'needles\'][0] # num of clean needles in infected users collection\n                    b = Node[\'needles\'][1] # num of infected needles in infected users collection\n\n                    if rnd.random()<a/(a+b): # chances that an uninfected needle is selected\n\n                        Node[\'needles\'][0]-=1   # a new needle is infected \n                        Node[\'needles\'][1]+=1   # with prob p_use*a/(a+b)                  \n\n        Energy.append(energy(g))\n        \n        clean_ndls.append(sum([nodes[nds][\'needles\'][0] for nds in nodes])) # updates the num of clean needles\n        infct_ndls.append(sum([nodes[nds][\'needles\'][1] for nds in nodes])) # updates the num of infected needles\n        \n        # keeping track of populations at each time step:\n        healthy_users = [x for x in nodes if nodes[x][\'health\']==0]\n        sick_users = [x for x in nodes if nodes[x][\'health\']==1]\n        \n\n        N_sick_0.append(len([x for x in g if nodes[x][\'health\']==1 and nodes[x][\'immunity_type\']==0]))\n        N_sick_1.append(len([x for x in g if nodes[x][\'health\']==1 and nodes[x][\'immunity_type\']==1]))\n        N_healthy_0.append(len([x for x in g if nodes[x][\'health\']==0 and nodes[x][\'immunity_type\']==0]))\n        N_healthy_1.append(len([x for x in g if nodes[x][\'health\']==0 and nodes[x][\'immunity_type\']==1]))\n\n        \n                                 \n        #------------------------------------ this section for printing the network ------------------------------------#\n#         colors = []\n        \n#         rand_pos = nx.spring_layout(g,pos=positions,fixed=positions.keys())\n    \n#         for node in g.nodes():\n#             if g.nodes[node][\'health\']==1:\n#                 colors.append(\'red\')\n#             else:\n#                 colors.append(\'blue\')\n            \n#         needl_labls = {}\n#         for node in g.nodes():\n#             needl_labls.update({node:g.nodes[node][\'needles\']})\n            \n#         labls_pos = {}  # needle label positions\n#         for pt in rand_pos:\n#             labls_pos.update({pt:rand_pos[pt]+np.array([0.05,0.05])}) # this will shift the labels a little to the right and up\n\n#         nde_labl_pos = {}  # node label positions\n#         for pt in rand_pos:\n#             nde_labl_pos.update({pt:rand_pos[pt]-np.array([0.05,0.05])}) # this will shift the labels a little to the left and down\n\n#         fig,ax = plt.subplots(figsize=graph_size)\n#         plt.axis(\'off\')\n#         nx.draw_networkx(g,pos=rand_pos,node_color=colors,edgelist=[],node_size=[300*g.nodes[nde][\'p_use\'] for nde in g.nodes()],with_labels=False)\n#         nx.draw_networkx_edges(g,pos=rand_pos,width=[5*g.edges[x,y][\'wght\'] for (x,y) in g.edges()],edge_color=[g.edges[x,y][\'color\'] for (x,y) in g.edges()])\n#         nx.draw_networkx_labels(g,pos=labls_pos,labels=needl_labls) # needle labels\n#         nx.draw_networkx_labels(g,pos=nde_labl_pos,labels=node_names,font_weight=\'bold\',font_size=15) # node labels \n#         plt.show()\n        #---------------------------------------------------------------------------------------------------------------#\n        \n        # this turns the red edges back to black at the end of each time step:\n        for edge in edges:\n            g.add_edge(edge[0],edge[1],color=\'k\')\n            \n        degrees.append(sum([g.degree(nde) for nde in g])/2)\n        \n        \n        female_edges = len([(x,y) for (x,y) in edges if nodes[x][\'block\']+nodes[y][\'block\']==0])\n        between_edges = len([(x,y) for (x,y) in edges if nodes[x][\'block\']+nodes[y][\'block\']==1])\n        male_edges = len([(x,y) for (x,y) in edges if nodes[x][\'block\']+nodes[y][\'block\']==2])\n    \n        edges_no.append([female_edges,between_edges,male_edges])\n            \n#         print(len(list(g.edges())))\n\n    N_healthy = [N_healthy_0,N_healthy_1]  # seperated by immunity type\n    N_sick = [N_sick_0,N_sick_1]\n        \n    return (N_healthy,N_sick,clean_ndls,infct_ndls,Energy,degrees,edges_no,birth,death)\n\n\n\n    \n#--- Running the simulation ---#\n\nOR = 0.68  # np.linspace(0.58,0.81,30)\nW,M = 0.5,0.5\nC = 0.26   # np.linspace(0.2,0.35,30)\na = (OR - 1)*W\nb = W + OR*M - (OR - 1)*C\nc = -C\np0_a = (-b+np.sqrt(b**2 - 4*a*c))/(2*a)    # <-- turns out to be the value between 0 and 1\np0_b = (-b-np.sqrt(b**2 - 4*a*c))/(2*a)\n\np0 = p0_a                     # % of type 0 that have the clearance allele\np1 = OR*p0/(1+(OR-1)*p0)      # % of type 1 that have the clearance allele\n\n\na_break,b_break = BETA(0.01111,0.0001)\na_link,b_link = BETA(0.9,0.01)\n\n\nnames = [\'A\',\'B\']\ngroup = {}\nfor name in names:\n    group.update({name:{\'size\':50,\'immunity\':(260,7000),\'lend\':(25,2),\'accept\':(25,2),\'use\':(5,5),\'break\':(a_break,b_break),\'link\':(a_link,b_link),\'drug_a\':(7,3),\'drug_b\':(5,5),\'drug_c\':(3,7)}})\n\n\nN = len(names) # number of groups\np_sick = 0.05 # ratio of initially sick to total population\np_decay = 0.96\np_birth = 1/365\np_death = 0.005/365\nt_steps = 3650\n\n\nsizes = [group[x][\'size\'] for x in group] # sizes of blocks A, B, C (the more connections between the blocks, the less community structure)\n\nilessj = [(i,j) for (i,j) in it.product(range(N),range(N)) if i<j]\n\nprobs = np.zeros([N,N])\n\nfor i in range(N):\n    probs[i,i] = beta(30,1000).rvs()\n    \nfor i,j in ilessj:\n    probs[i,j] = beta(20,1000).rvs()\n    probs[j,i] = probs[i,j]\n    \ng = nx.stochastic_block_model(sizes, probs)\n\nNeedles = []\nfor i in range(sum(sizes)):\n    Needles.append([rnd.randint(1,3),0])   # here we imagine that everyone starts off wih at least one clean needle\n\n\n# saving the positions for the example graphs\n# save_obj(nx.spring_layout(g),\'temp_pos\')    \npositions = nx.spring_layout(g)\n\nk = 0\nAlpha = 0.5  # this quantifies the % of a community sampling from the high clearance distribution, 1-Alpha has the low\nBeta = 0.5 # this quantifies the % of communites that have sample from the high clearance distribution, 1-Beta has the low\n\n\nfor name in names:\n    size = group[name][\'size\']\n    P_lend = beta(group[name][\'lend\'][0],group[name][\'lend\'][1]).rvs(size=size)\n    P_accept = beta(group[name][\'accept\'][0],group[name][\'accept\'][1]).rvs(size=size)\n    P_use = beta(group[name][\'use\'][0],group[name][\'use\'][1]).rvs(size=size)\n    P_break = beta(group[name][\'break\'][0],group[name][\'break\'][1]).rvs(size=size)\n    P_link = beta(group[name][\'link\'][0],group[name][\'link\'][1]).rvs(size=size)\n    Drug_a = beta(group[name][\'drug_a\'][0],group[name][\'drug_a\'][1]).rvs(size=size)\n    Drug_b = beta(group[name][\'drug_b\'][0],group[name][\'drug_b\'][1]).rvs(size=size)\n    Drug_c = beta(group[name][\'drug_c\'][0],group[name][\'drug_c\'][1]).rvs(size=size)\n    Age = [int(norm(33,5).rvs()) for i in range(size)]    # normal distribution of ages centered on 33 spread of 5\n    Target = nbinom(5,0.6).rvs(size=size)   # target number of neighbors\n    \n    # turn on for heterogenous mixing determined by Alpha -------------- #\n    Immunity = clearance(1,size,p0,p1,0.00444) if name==\'A\' else clearance(0,size,p0,p1,0.00444)   \n    # ------------------------------------------------------------------ #\n    \n    # turn on for homogenous mixing determined by Beta ----------------- #\n#     if rnd.random()<Beta:\n#         Immunity = clearance(0,size,p0,p1,0.00444)  \n#     else:\n#         Immunity = clearance(1,size,p0,p1,0.00444)\n    # ------------------------------------------------------------------ #\n    \n    i = 0\n    for node in range(k,k+size):\n        drug_norm = 1-P_use[i]+Drug_a[i]+Drug_b[i]+Drug_c[i]  # normalization for the probabilites\n        drug_a = Drug_a[i]/drug_norm\n        drug_b = Drug_b[i]/drug_norm\n        drug_c = Drug_c[i]/drug_norm\n        g.add_node(node,needles=Needles[node],health=sick(p_sick),immunity=Immunity[i][0],immunity_type=Immunity[i][1],p_lend=P_lend[i],p_accept=P_accept[i],p_use=P_use[i],p_break=P_break[i],p_link=P_link[i],drug_a=drug_a,drug_b=drug_b,drug_c=drug_c,age=Age[i],target=Target[i])\n        i+=1\n    k+=size\n\nnodes = g.nodes\nfor edge in g.edges():\n    a = nodes[edge[0]][\'p_use\']\n    b = nodes[edge[1]][\'p_use\']\n    x = (nodes[edge[0]][\'p_lend\']+nodes[edge[0]][\'p_accept\'])/2\n    y = (nodes[edge[1]][\'p_lend\']+nodes[edge[1]][\'p_accept\'])/2\n    dd = sum([nodes[edge[0]][drug]*nodes[edge[1]][drug] for drug in [\'drug_a\',\'drug_b\',\'drug_c\']])\n    g.add_edge(edge[0],edge[1],color=\'k\',wght=a*b*(x+y)*dd)   # here wght gives a measure of how often two uses share needles of the same drug type \n\n\n(N_healthy,N_sick,clean_ndls,infct_ndls,Energy,Degrees,Edges_no,birth,death) = HCV_ABM_2(g,positions,p_decay,p_birth,p_death,t_steps)\n\npops = [N_healthy,N_sick,clean_ndls,infct_ndls,Energy,Degrees,Edges_no,birth,death]\n# save_obj(pops,\'pops test\')')

